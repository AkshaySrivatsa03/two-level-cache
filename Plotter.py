# Author - Akshay Srivatsa

# This file is used to read log files produced by ndnSIM
# and plot graphs based on the data produced

# import statements to analyze and produce graphs
import matplotlib.pyplot as pt
import sys
import os
import random

# Description -
# This script is used to clean the log files generated by ndnISM, analyse them and
# produce graphs as required

# Map each word to its count
parsing = {}

# This list is used to store all lines from the original log file which contain the
# information about interest packets
content_lines = []

# This list contains all the lines from the original log file which contain the
# information about the hop counts
hop_lines = []

# This variable is used to keep only those lines which contain the necessary words
# for analysis
phrases = ["getName()", "ndn.Consumer:OnData():", "Hop", "Data getting evicted: /root/client/"]

# This list of lists stores values of individual lines
# of the graph
list_of_y_axes_values = []

# This variables represents the total number of clients currently under consideration
total_number_of_clients = 0

# This list helps to create different colours for each line of the graph
list_of_colours_used = []

# This variable stores the name of the file that is created
# after the first stage of cleaning the log files
cleaned_file = ""

# This method adds values of hop counts for each consumer to
# the respective list
def add_to_list(client, hop_count, hop_count_value):
    global list_of_y_axes_values
    global total_number_of_clients

    current_list = list_of_y_axes_values[hop_count]

    # Initialize length of each list to toal number of clients
    if len(current_list) < total_number_of_clients:
        for i in range(total_number_of_clients):
            current_list.append(0)
        current_list[client] = hop_count_value

    else:
        current_list[client] = hop_count_value

    list_of_y_axes_values[hop_count] = current_list

    return None

# Find which line style is being used
def random_colour():
    global list_of_colours_used

    done = False
    colour = []

    while not done:
        Red = random.uniform(0.1, 0.9)
        Green = random.uniform(0.1, 0.9)
        Blue = random.uniform(0.1, 0.9)

        colour = [Red, Green, Blue]

        if colour not in list_of_colours_used:
            list_of_colours_used.append(colour)
            done = True

    return colour

# This method is used to find the average number of hops (Cache Hit Distance)
def average_number_of_hops(array_of_hops):

    weighted_sum = 0

    for each in range(len(array_of_hops)):
        weighted_sum += array_of_hops[each] * each

    average_number = int(weighted_sum/len(array_of_hops)) + 1

    return average_number

# This method is used obtain plots for Cache Hit Distance(Hop Count) vs Frequencies
# directly from the original log file
def plot_graph_2_direct(original_log_filefile):

    global phrases

    cache_hit_distance_lines = []
    no_of_occurences = []

    with open(original_log_filefile, 'r') as log_file:
        while True:
            line = log_file.readline()
            if not line:
                break
            else:
                for each in range(len(phrases)):
                    if each == 0:
                        continue
                    else:
                        if each < len(phrases) - 2:
                            if phrases[each] in line and phrases[each+1] in line:
                                cache_hit_distance_lines.append(line)

    for each in cache_hit_distance_lines:
        cache_distance_line = each.split()
        if str(cache_distance_line[4]) == 'Hop':
            value = int(cache_distance_line[6])
            if value > len(no_of_occurences):
                no_of_occurences = [0 for each in range(value+1 - len(no_of_occurences))]
                no_of_occurences[value] = 1
            else:
                val = no_of_occurences[value]
                val += 1
                no_of_occurences[value] = val

    x_values = [int(each) for each in range(len(no_of_occurences))]
    x_values.remove(0)
    print("X values are: " + str(x_values))

    average_hops = average_number_of_hops(no_of_occurences)

    no_of_occurences = percentage(no_of_occurences)
    no_of_occurences.remove(0)

    print("Y values are: " + str(no_of_occurences))

    for each in range(len(no_of_occurences)):
        no_of_occurences[each] *= 100

    print("Y values by 100 : " + str(no_of_occurences))

    print("Average number of hops is :" + str())

    print("Average Cache Hit Distance is : " + str(average_hops))

    return None

# This method produces graphs for Cache Eviction vs Request Rate
def plot_graph_5(original_log_file):

    global phrases
    evict_lines = []
    eviction_numbers = []

    with open(original_log_file, "r") as log_file:
        while True:
            line = log_file.readline()
            if not line:
                break
            else:
                for each in range(len(phrases)):
                    if each == 3:
                        if phrases[each] in line:
                            evict_lines.append(line)

    # count evictions for content
    for each_line in evict_lines:
        client = each_line.split()
        client = client[3].split("/root/client/")
        cli = str(client[1])
        content = int(cli[0])
        if len(eviction_numbers) == content:
            eviction_numbers.append(0)
        elif len(eviction_numbers) < content:
            for i in range((content-len(eviction_numbers)+1) ):
                eviction_numbers.append(0)
        eviction_numbers[content] += 1

    print("Full numbers are " + str(eviction_numbers))

    total = 0

    for each in range(len(eviction_numbers)):
        total += eviction_numbers[each]

    print("Total is " + str(total))

    for each in range(len(eviction_numbers)):
        eviction_numbers[each] = eviction_numbers[each]/total

    print("Percents are :" + str(eviction_numbers))

    return None

# This method produces the graph of Number of Hops vs Request Rate
# when the data is not cleaned
def plot_graph_3(original_log_file):

    global phrases

    hop_count_lines = []
    list_of_hop_counts = {}
    maximum_number_of_hops = 0

    with open(original_log_file, "r") as log_file:
        while True:
            line = log_file.readline()
            if not line:
                break
            else:
                for each in range(len(phrases)):
                    if each == 0:
                        continue
                    else:
                        if each < len(phrases) - 1:
                            if phrases[each] in line and phrases[each+1] in line:
                                hop_count_lines.append(line)

    for each_line in hop_count_lines:
        new_value = each_line.split()
        if new_value[4] == 'Hop':
            values = new_value[6]
            if values not in list_of_hop_counts:
                list_of_hop_counts[values] = 1
            else:
                value_to_increase = list_of_hop_counts[values]
                value_to_increase += 1
                list_of_hop_counts[values] = value_to_increase
        else:
            continue

    for each in list_of_hop_counts:
        if int(each) > maximum_number_of_hops:
            maximum_number_of_hops = int(each)

    hop_counts = [0 for each in range(maximum_number_of_hops+1)]

    total_hops = 0
    for each in list_of_hop_counts:
        hop_counts[int(each)] = int(list_of_hop_counts[each])
        total_hops += int(list_of_hop_counts[each])

    percentages = [0 for each in range(len(hop_counts))]

    for each in range(len(percentages)):
        percentages[each] = hop_counts[each]/total_hops

    # print(str(hop_counts))
    print(str(percentages))
    return None

# This method produces the graph of Number of Hops vs Request Rate
# when the data is cleaned
def plot_graph_3_cleaned(y_valuee):

    number_of_hops = [0 for each_hop in range(len(y_valuee))]

    for each in range(len(y_valuee)):
        hop_number = y_valuee[each]
        total = 0
        for every in hop_number:
            total += every
        number_of_hops[each] = total

    print(str(number_of_hops))

    return None

# This method calculates the percentage of
def percentage(list_of_frequencies):

    total = 0

    for each in range(len(list_of_frequencies)):
        total += list_of_frequencies[each]

    for each in range(len(list_of_frequencies)):
        list_of_frequencies[each] = list_of_frequencies[each]/total

    return list_of_frequencies

# This method plots the graph of Hop Count(Cache Hit Distance) vs Frequency
def plot_graph_2(y_values):

    list_of_frequencies = []
    list_of_hopcounts = []

    for hop_count in range(len(y_values)):
        list_of_hopcounts.append(hop_count)
        frequency = 0
        hops = y_values[hop_count]
        for each in hops:
            if each != 0:
                frequency += each

        list_of_frequencies.append(frequency)

    list_of_frequencies_in_percentage = percentage(list_of_frequencies)
    list_of_frequencies_in_percentage.remove(0.0)
    print(str(list_of_frequencies_in_percentage))
    list_of_hopcounts.remove(0)
    print(str(list_of_hopcounts))
    fig = pt.figure()
    ax = fig.add_subplot(111)
    colour = random_colour()
    pt.xlabel("Hop Counts")
    pt.ylabel("Frequencies in percentage")
    pt.plot(list_of_hopcounts, list_of_frequencies_in_percentage, linewidth=4, color=colour, linestyle='-', marker='o')
    xy = zip(list_of_hopcounts, list_of_frequencies_in_percentage)
    for each in list(xy):
        for eachy in range(len(each)):
            if eachy == 1:
                if each[eachy] != 0:
                    ax.annotate(str(each), xy=each)
    pt.show()

    return None

# This method is used to actually produce the graph of content ID vs hopcount
# It only plots lines which contain a substantial amount of information
def plot_graph_1(x_values, y_values):
    global total_number_of_clients

    lines_to_tag = []

    for y_vals in y_values:
        count = 0
        for val in y_vals:
            if int(val) != 0:
                count += 1
        if count > int(total_number_of_clients/4):
            color = random_colour()
            lab = 'Hop Count ' + str(y_values.index(y_vals))
            lines_to_tag.append(lab)
            print(str(y_vals))
            pt.plot(x_values, y_vals, linewidth=4, color=color, linestyle='dashed')
    print("X values are " + str(x_values))
    pt.xlabel("Content IDs")
    pt.ylabel("Number of requests served")
    pt.legend( lines_to_tag, loc=1 )
    pt.show()

    return None

# This method is used to create the requisite graphs
def produce_graph():
    global parsing
    global list_of_y_axes_values
    global total_number_of_clients

    upper_limit = 0
    largest_number_of_hops = 0

    # Find how many maps to create
    for each in parsing:
        name = str(each)
        name = name.split("/root/client/")
        name = str(name[1])
        name = int(name[0])
        if upper_limit < int(name):
            upper_limit = int(name)

    # Find what is the largest hop count
    for consumer in parsing:
        values = (parsing[consumer]).split(" ")
        for hop in values:
            if hop != "" and hop != " ":
                if int(hop) > largest_number_of_hops:
                    largest_number_of_hops = int(hop)

    # Make a list of maps so we can make graphs
    # upper_limit+1 is used as we start from client 0 and python stops looping
    # one number before the value passed as an argument to the range function
    list_of_maps = [{} for each in range(upper_limit+1)]
    list_of_y_axes_values = [[] for each in range(largest_number_of_hops+1)]
    total_number_of_clients = len(list_of_maps)

    for key in parsing:
        name = str(key).split("/root/client/")
        name = str(name[1])
        name = int(name[0])
        values = (parsing[key]).split(" ")
        # Add each content's hop count value to individual maps
        for each in values:
            if each != "" and each != " ":
                if str(each) not in list_of_maps[int(name)]:
                    list_of_maps[int(name)] [str(each)] = 1
                else:
                    value = list_of_maps[int(name)] [str(each)]
                    value += 1
                    list_of_maps[int(name)] [str(each)] = value

    x_values_of_graph = [client for client in range(upper_limit+1)]

    for client in range(len(list_of_maps)):
        for hop_count in list_of_maps[client]:
            for i in range(largest_number_of_hops+1):
                if int(hop_count) == int(i):
                    add_to_list(int(client), int(hop_count), int(list_of_maps[client] [hop_count]) )
                    break
                else:
                    continue

    plot_graph_1(x_values_of_graph, list_of_y_axes_values)
    plot_graph_2(list_of_y_axes_values)

    return None

# This method is used to analyse the log files
def reading_file():

    global parsing
    global cleaned_file

    input_file = open(cleaned_file, 'r')
    while True:
        line = input_file.readline()
        if not line:
            break
        words = line.split()
        key = words[6]
        new_line = input_file.readline()
        if not new_line:
            break
        else:
            new_value = new_line.split()
            if new_value[4] == 'Hop':
                values = new_value[6]
                if key not in parsing:
                    parsing[key] = values + ' '
                else:
                    parsing[key] = parsing[key]+values + ' '
            else:
                continue

    # print(str(parsing))
    input_file.close()
    # Cleaning up
    os.remove(cleaned_file)

# This method is used to write a .txt file which contains cleaned log statements
def write_cleaned_file():
    global cleaned_file
    global content_lines
    global hop_lines

    with open(cleaned_file, "w") as cleaned_log_file:
        for content_line in content_lines:
            content_words = content_line.split()
            for hop_line in hop_lines:
                hop_words = hop_line.split()
                if int(content_words[1]) == int(hop_words[1]):
                    cleaned_log_file.write("".join(str(content_line)) )
                    cleaned_log_file.write("".join(str(hop_line)) )
                    break
                else:
                    continue

    return None

# This method is used to clean the original log file
def clean_file(name_of_file):
    global cleaned_file
    global phrases
    global content_lines
    global hop_lines

    if ".log" in name_of_file:
        temp_name = name_of_file.split(".log")
        cleaned_file = temp_name[0] + ".txt"
    elif ".txt" in name_of_file:
        temp_name = name_of_file.split(".txt")
        cleaned_file = temp_name[0] + "1" + ".txt"
    else:
        print("File extension type not recognized")
        print("Please provide a .txt or .log file")
        sys.exit(0)

    with open(name_of_file, "r") as log_file:
        while True:
            line = log_file.readline()
            if not line:
                break
            else:
                for each in range(len(phrases)):
                    if each == 0:
                        if phrases[each] in line:
                            content_lines.append(line)
                    else:
                        if each < len(phrases) - 1:
                            if phrases[each] in line and phrases[each+1] in line:
                                hop_lines.append(line)

    return None

# This method can be implemented to read name of all log files that
# are to be analyzed from a file
def read_names_from_file(names_of_log_files):

    number_of_times =0

    return number_of_times

# This method is used to obtain plots a certain number of times
def get_outputs(number_of_times):

    for each in range(number_of_times+1):
        write_cleaned_file()
        reading_file()
        produce_graph()

    return None

# The main method
def main():
    print("Please provide a .txt or .log file")
    direction = str(input("Is there a file containing the names of all log files? Y/N "))
    if direction.lower() == "y":
        names_of_log_files = input("Please enter the name of the file if it is in the same directory,"
                                   "or full path if it is not ")
        number_of_times = read_names_from_file(names_of_log_files)
        get_outputs(number_of_times)
    else:
        original_log_file=input("Name of log file (please provide complete path if not in the same directory) ")
        # plot_graph_5(original_log_file)
        # plot_graph_3(original_log_file)
        plot_graph_2_direct(original_log_file)
        # clean_file(original_log_file)
        # get_outputs(1)

main()
